#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('ctrlaccess:server');
var http = require('http');
var path = require('path');
var fs = require('fs'); //required for file serving
//var https = require('https');
/**
 * Get port from environment and store in Express.
 */
const host = 'localhost';
//const host = '192.168.1.50';

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */
var server = http.createServer(app);

// var server = https.createServer({
//     key: fs.readFileSync('./bin/ssl/my_cert.key'),
//     cert: fs.readFileSync('./bin/ssl/my_cert.crt'),
//     ca: fs.readFileSync ( './bin/ssl/my_cert.csr' )
// }, app)


// http.createServer(app).listen(80);
// app.use(function(req, res, next) {
//     if (req.secure) {
//         next();
//     } else {
//         res.redirect('https://' + req.headers.host + req.url);
//     }
// });
/**
 * Listen on provided port, on all network interfaces.
 */


//);

// socket.on('image', function(socket){
//    console.log(socket);
//   fs.readFile(__dirname + '/../public/video/cam1.jpg', function(err, buf){
//     video.emit('new_image', { image: true, buffer: buf.toString('base64')});
//     video.disconte
//   });
//});

//  });
//server.listen(host ,port);
server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

//const server2 = http.createServer(app).listen(3001);
users = {}
ids_disconnect = []
const io = require('socket.io')(server);
//trying to serve the image file from the server
const video = io.of('/video');
video.on('connection', function(socket) {
    console.log("client:" + socket.id);
    let dir = path.join(__dirname, "..")
    dir = path.join(dir, "public")
    dir = path.join(dir, "video")
    let dir_picture = path.join(dir, "images")
    //dir_picture = path.join(dir_picture, "")
    //console.log(dir_picture)
    // dir = path.join(dir, "video.webp")
    dir = path.join(dir, "video.jpg")
    let cont = 0;
   
    //console.log(dir)
    // setInterval(() => {
        fs.readFile(dir, function(err, buf) {
             //console.log("conectandooooooooooooooooooooooooooooooooooooo dentro")
            //console.log( buf.toString('base64').length)
            //if ((buf.length > 10) && (
              //    (buf.toString('base64')[buf.toString('base64').length - 5] == "/") ||
               // (buf.toString('base64')[buf.toString('base64').length - 4] == "/"))) { //80000
            // if(buf.toString('base64').length!=0){//80000
            //console.log(buf.length)
            // console.log( buf.toString('base64')[buf.toString('base64').length-1])
            //console.log(buf)
            // console.log(buf.length)
            //if (buf.length > 0) {
                //console.log(buf.length)
                //console.log(buf.toString('base64'))
                //cont += 1
               // console.log("Num:" + cont)
                socket.emit('new_image', { recognizer: false, image: true, buffer: buf.toString('base64') }); //imprimiendo el id del cliente conectado 
                //console.log("conectandooooooooooooooooooooooooooooooooooooo dentro")
                //console.log('image file is initialized');
                //}
            //}

        })
    // },100)
    socket.on('image', function() {
        //console.log("Estoy en imgaen")
        fs.readFile(dir, function(err, buf) {
            //console.log( buf.toString('base64').length)
            if ((buf.length > 10) && (
                    (buf.toString('base64')[buf.toString('base64').length - 5] == "/") ||
                    (buf.toString('base64')[buf.toString('base64').length - 4] == "/"))) {
                socket.emit('new_image', { recognizer: false, image: true, buffer: buf.toString('base64') });
            }

        })

    })

    // si esxite el archvo tal manada d
    // socket.on("disconet", function(img) {
    //     console.log("Cliente desconcetado")

    // })
    // socket.on("give", function(img) {
    //     fs.readFile(dir, function(err, buf) {
    //        socket.broadcast.emit('new_image', { image: true, buffer: buf.toString('base64') }); //imprimiendo el id del cliente conectado 
    //         //console.log('image file is initialized');
    //     })
    // })




    var user_id = socket.id; //socket.decoded_token.user;


    if (users[user_id] === undefined) {
        users[user_id] = { "socket": socket };
    } else {
        console.log('Se ha connectado otro usuario ' + user_id);
        ids_disconnect.push(users[user_id].socket.id);
        users[user_id].socket.disconnect(true);
        users[user_id] = { "socket": socket };
    }

    console.log("User Connect: " + user_id + " SocketID: " + socket.id);



    //disconnect client
    socket.on('disconnect', function() {
        console.log('User Disconnect ' + user_id);
        if (ids_disconnect.indexOf(socket.id) != -1) {
            console.log('Disconnect Force: ' + user_id);
            ids_disconnect.splice(ids_disconnect.indexOf(socket.id), 1)
        } else {
            delete users[user_id];
            socket.disconnect(true)
            users[user_id] = undefined; // <-------- Está es la linea que agregué
        }
    });

    socket.on("give_pictures", function(img) {
        fs.readdir(dir_picture, (err, files) => {
            let tam = files.length
            if (err) throw err;
            let ordFiles = files.sort((a, b) => {
                let aa = parseInt(a.split("."));
                let bb = parseInt(b.split("."));
                //aa - bb
                if (aa > bb) {
                    return 1;
                }
                if (aa < bb) {
                    return -1;
                }
                return 0;
            })
            video.emit("rec_img", ordFiles)
        });

    })
});







/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
    var port = parseInt(val, 10);

    if (isNaN(port)) {
        // named pipe
        return val;
    }

    if (port >= 0) {
        // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    var bind = typeof port === 'string' ?
        'Pipe ' + port :
        'Port ' + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case 'EACCES':
            console.error(bind + ' requires elevated privileges');
            process.exit(1);
            break;
        case 'EADDRINUSE':
            console.error(bind + ' is already in use');
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
    var addr = server.address();
    var bind = typeof addr === 'string' ?
        'pipe ' + addr :
        'port ' + addr.port;
    debug('Listening on ' + bind);
}